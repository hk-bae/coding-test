# Dynamic Programming

* 동적계획법은 문제를 작은 문제들의 반복으로 **정의할 수 있는 문제에 대한 일반적인 알고리즘 설계 기법**



* 핵심 아이디어
  1. 인스턴스는 더 작은 인스턴스의 해답을 이용하여 풀이된다.
  2. 더 작은 인스턴스의 해답이 여러 번 반복적으로 사용된다.
  3. 더 작은 인스턴스의 해답을 테이블에 저장하여 한번만 계산되도록 한다.
  4. 시간효율을 높이는 대신 추가 메모리 공간이 필요하다.



* 특정 문제가 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 DP를 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인
* 우선 단순 재귀 함수로 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 활용될 수 있다면 (즉 메모이제이션 기법을 적용할 수 있다면) 코드를 개선하는 것도 좋은 아이디어이다.
* 가능하다면 재귀함수를 이용하는 탑다운 방식보다는 바텀업 방식으로 구현하는 것을 권장
  * 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있다.
  * 이 경우 sys라이브러리에 포함된 setrecurswionlimit() 함수를 호출하여 재귀 제한을 완화할 수 있다

### Example1 : 피보나치 수열 (top - down)

* f(n) = f(n-1) + f(n-2),  f(1) = 1, f(2) = 1

  ```python
  def fibo(x):
    if x == 1 or x == 2 :
      return 1
    return fibo(x - 1) + fibo(x - 2)
  ```

* 위와 같은 피보나치 수열의 소스코드는 심각한 문제를 발생시킬 수 있다.

* f(n)에서 n이 커지면 커질 수록 수행 시간이 기하급수적으로 늘어나게 된다.

* 시간복잡도는 O(2^N)으로 지수 시간이 소요된다.



* 이를 DP를 활용해서 해결하자
  * 인스턴스는 더 작은 인스턴스의 해답을 이용하여 풀이된다.
  * 더 작은 인스턴스의 해답이 여러 번 반복적으로 사용된다.

* 메모이제이션 기법
  * 한번 구한 결과를 메모리 공간에 저장해두고 같은 식을 다시 호출하면 저장한 값을 그대로 가져오는 기법
  * 캐싱이라고도 한다.

```python
# 한 번 계산된 결과를 메모제이션 하기 위한 리스트 초기화
d = [0] * 100

def fibo(x):
  if x == 1 or x == 2 :
    return 1
  #저장되어 있다면 값 반환
  if d[x] != 0 :
    return d[x]
  #아직 계산된적 없던 문제
  d[x] = fibo(x - 1) + fibo(x - 2)
  return d[x]
```

* 이는 시간 복잡도 O(N)이 소요된다.
* 한 번 구한 결과는 다시 계산되지 않는다.



* 이와 같이 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식을 **탑다운 방식** 이라 한다.

* 반면 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 **바텀업 방식** 이라 한다.

* 아래는 바텀업 방식으로 해결한 예시이다.

  ```python
  	d = [0] * 100
    
    d[1] = 1
    d[2] = 1
    
    n = 99
    
    for i in range(3, n+1) :
      d[i] = d[i-1] + d[i-2]
  ```



* 다이나믹 프로그래밍의 전형적인 형태는 바텀업 방식이다.
  * 바텀업 방식에서 사용되는 결과 저장용 리스트를 'DP 테이블' 이라 한다.
* 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.
* 엄밀하게는, 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미하므로 다이나믹 프로그래밍과는 별도의 개념이다.



### Example 2 : Coin-Row Problem

* n개의 동전이 한줄로 놓여 있을 때, 가장 총합이 크도록 동전을 선택하는 문제
* 이때 인접한 두 개의 동전은 절대 선택할 수 없음.



* F(n) : n개의 동전 중 선택한 동전의 최대 합
* F(n)을 위한 반복을 위해 동전을 선택할 때,
  * n번째 동전을 선택하는 경우 : n-2 번째 까지의 max 값이 필요
  * n번째 동전을 선택하지 않는 경우 : n-1 번째 까지의 max 값이 필요
* F(n) = max{ F(n-2) + C(n) , F(n-1)} for n > 1 ( C(n) 은 n번째 동전의 가치 ), F(0) = 0 F(1) = C(1)



``` python
def coinRow(array) :
	results = [-1] * len(array)
  results[0] = 0
  results[1] = array[1]
  for i in range(2,len(array)) :
    results[i] = max(array[i] + results[i-2], array[i-1])
  return results[len(array)]
```



### Example 3 : Change-Making Problem

* 동전 거스름돈 문제 : n 값의 동전을 건낼 때, 동전 개수를 최소화 하는 문제
* 각 동전의 개수는 무한대라고 가정
* 각 동전의 가치는 d1<d2<...<dm, d1 = 1



* F(n) : 거스름돈 n에 대한 최소 동전 수
* F(n)을 위해 동전을 선택할 때
  * F(n) = min{ F(n - d(j)) } + 1 for n > 0 ( n >= d(j) ) 
  * F(0) = 0



``` python
# 동전 배열 coins와 거슬러줄 돈 n
def changeMaking(coins,n) :
	results = [0] * (n+1)
  for i in range(1,n+1) :
    tmp = 1e9
    j = 1
    while j < len(coins) and i >= coins[j] :
      tmp = min(results[i-coins[j]], tmp)
      j = j + 1
    results[i] = tmp + 1
 return results
```

